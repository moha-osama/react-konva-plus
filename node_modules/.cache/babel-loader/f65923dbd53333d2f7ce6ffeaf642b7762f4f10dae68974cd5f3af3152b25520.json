{"ast":null,"code":"import { CompleteMultipartUploadCommand, CreateMultipartUploadCommand, PutObjectCommand, PutObjectTaggingCommand, UploadPartCommand } from \"@aws-sdk/client-s3\";\nimport { AbortController } from \"@smithy/abort-controller\";\nimport { getEndpointFromInstructions, toEndpointV1 } from \"@smithy/middleware-endpoint\";\nimport { extendedEncodeURIComponent } from \"@smithy/smithy-client\";\nimport { EventEmitter } from \"events\";\nimport { byteLength } from \"./bytelength\";\nimport { getChunk } from \"./chunker\";\nconst MIN_PART_SIZE = 1024 * 1024 * 5;\nexport class Upload extends EventEmitter {\n  constructor(options) {\n    super();\n    this.MAX_PARTS = 10000;\n    this.queueSize = 4;\n    this.partSize = MIN_PART_SIZE;\n    this.leavePartsOnError = false;\n    this.tags = [];\n    this.concurrentUploaders = [];\n    this.uploadedParts = [];\n    this.isMultiPart = true;\n    this.queueSize = options.queueSize || this.queueSize;\n    this.partSize = options.partSize || this.partSize;\n    this.leavePartsOnError = options.leavePartsOnError || this.leavePartsOnError;\n    this.tags = options.tags || this.tags;\n    this.client = options.client;\n    this.params = options.params;\n    this.__validateInput();\n    this.totalBytes = byteLength(this.params.Body);\n    this.bytesUploadedSoFar = 0;\n    this.abortController = options.abortController ?? new AbortController();\n  }\n  async abort() {\n    this.abortController.abort();\n  }\n  async done() {\n    return await Promise.race([this.__doMultipartUpload(), this.__abortTimeout(this.abortController.signal)]);\n  }\n  on(event, listener) {\n    this.uploadEvent = event;\n    return super.on(event, listener);\n  }\n  async __uploadUsingPut(dataPart) {\n    this.isMultiPart = false;\n    const params = {\n      ...this.params,\n      Body: dataPart.data\n    };\n    const clientConfig = this.client.config;\n    const requestHandler = clientConfig.requestHandler;\n    const eventEmitter = requestHandler instanceof EventEmitter ? requestHandler : null;\n    const uploadEventListener = event => {\n      this.bytesUploadedSoFar = event.loaded;\n      this.totalBytes = event.total;\n      this.__notifyProgress({\n        loaded: this.bytesUploadedSoFar,\n        total: this.totalBytes,\n        part: dataPart.partNumber,\n        Key: this.params.Key,\n        Bucket: this.params.Bucket\n      });\n    };\n    if (eventEmitter !== null) {\n      eventEmitter.on(\"xhr.upload.progress\", uploadEventListener);\n    }\n    const resolved = await Promise.all([this.client.send(new PutObjectCommand(params)), clientConfig?.endpoint?.()]);\n    const putResult = resolved[0];\n    let endpoint = resolved[1];\n    if (!endpoint) {\n      endpoint = toEndpointV1(await getEndpointFromInstructions(params, PutObjectCommand, {\n        ...clientConfig\n      }));\n    }\n    if (!endpoint) {\n      throw new Error('Could not resolve endpoint from S3 \"client.config.endpoint()\" nor EndpointsV2.');\n    }\n    if (eventEmitter !== null) {\n      eventEmitter.off(\"xhr.upload.progress\", uploadEventListener);\n    }\n    const locationKey = this.params.Key.split(\"/\").map(segment => extendedEncodeURIComponent(segment)).join(\"/\");\n    const locationBucket = extendedEncodeURIComponent(this.params.Bucket);\n    const Location = (() => {\n      const endpointHostnameIncludesBucket = endpoint.hostname.startsWith(`${locationBucket}.`);\n      const forcePathStyle = this.client.config.forcePathStyle;\n      if (forcePathStyle) {\n        return `${endpoint.protocol}//${endpoint.hostname}/${locationBucket}/${locationKey}`;\n      }\n      if (endpointHostnameIncludesBucket) {\n        return `${endpoint.protocol}//${endpoint.hostname}/${locationKey}`;\n      }\n      return `${endpoint.protocol}//${locationBucket}.${endpoint.hostname}/${locationKey}`;\n    })();\n    this.singleUploadResult = {\n      ...putResult,\n      Bucket: this.params.Bucket,\n      Key: this.params.Key,\n      Location\n    };\n    const totalSize = byteLength(dataPart.data);\n    this.__notifyProgress({\n      loaded: totalSize,\n      total: totalSize,\n      part: 1,\n      Key: this.params.Key,\n      Bucket: this.params.Bucket\n    });\n  }\n  async __createMultipartUpload() {\n    if (!this.createMultiPartPromise) {\n      const createCommandParams = {\n        ...this.params,\n        Body: undefined\n      };\n      this.createMultiPartPromise = this.client.send(new CreateMultipartUploadCommand(createCommandParams));\n    }\n    return this.createMultiPartPromise;\n  }\n  async __doConcurrentUpload(dataFeeder) {\n    for await (const dataPart of dataFeeder) {\n      if (this.uploadedParts.length > this.MAX_PARTS) {\n        throw new Error(`Exceeded ${this.MAX_PARTS} as part of the upload to ${this.params.Key} and ${this.params.Bucket}.`);\n      }\n      try {\n        if (this.abortController.signal.aborted) {\n          return;\n        }\n        if (dataPart.partNumber === 1 && dataPart.lastPart) {\n          return await this.__uploadUsingPut(dataPart);\n        }\n        if (!this.uploadId) {\n          const {\n            UploadId\n          } = await this.__createMultipartUpload();\n          this.uploadId = UploadId;\n          if (this.abortController.signal.aborted) {\n            return;\n          }\n        }\n        const partSize = byteLength(dataPart.data) || 0;\n        const requestHandler = this.client.config.requestHandler;\n        const eventEmitter = requestHandler instanceof EventEmitter ? requestHandler : null;\n        let lastSeenBytes = 0;\n        const uploadEventListener = (event, request) => {\n          const requestPartSize = Number(request.query[\"partNumber\"]) || -1;\n          if (requestPartSize !== dataPart.partNumber) {\n            return;\n          }\n          if (event.total && partSize) {\n            this.bytesUploadedSoFar += event.loaded - lastSeenBytes;\n            lastSeenBytes = event.loaded;\n          }\n          this.__notifyProgress({\n            loaded: this.bytesUploadedSoFar,\n            total: this.totalBytes,\n            part: dataPart.partNumber,\n            Key: this.params.Key,\n            Bucket: this.params.Bucket\n          });\n        };\n        if (eventEmitter !== null) {\n          eventEmitter.on(\"xhr.upload.progress\", uploadEventListener);\n        }\n        const partResult = await this.client.send(new UploadPartCommand({\n          ...this.params,\n          UploadId: this.uploadId,\n          Body: dataPart.data,\n          PartNumber: dataPart.partNumber\n        }));\n        if (eventEmitter !== null) {\n          eventEmitter.off(\"xhr.upload.progress\", uploadEventListener);\n        }\n        if (this.abortController.signal.aborted) {\n          return;\n        }\n        if (!partResult.ETag) {\n          throw new Error(`Part ${dataPart.partNumber} is missing ETag in UploadPart response. Missing Bucket CORS configuration for ETag header?`);\n        }\n        this.uploadedParts.push({\n          PartNumber: dataPart.partNumber,\n          ETag: partResult.ETag,\n          ...(partResult.ChecksumCRC32 && {\n            ChecksumCRC32: partResult.ChecksumCRC32\n          }),\n          ...(partResult.ChecksumCRC32C && {\n            ChecksumCRC32C: partResult.ChecksumCRC32C\n          }),\n          ...(partResult.ChecksumSHA1 && {\n            ChecksumSHA1: partResult.ChecksumSHA1\n          }),\n          ...(partResult.ChecksumSHA256 && {\n            ChecksumSHA256: partResult.ChecksumSHA256\n          })\n        });\n        if (eventEmitter === null) {\n          this.bytesUploadedSoFar += partSize;\n        }\n        this.__notifyProgress({\n          loaded: this.bytesUploadedSoFar,\n          total: this.totalBytes,\n          part: dataPart.partNumber,\n          Key: this.params.Key,\n          Bucket: this.params.Bucket\n        });\n      } catch (e) {\n        if (!this.uploadId) {\n          throw e;\n        }\n        if (this.leavePartsOnError) {\n          throw e;\n        }\n      }\n    }\n  }\n  async __doMultipartUpload() {\n    const dataFeeder = getChunk(this.params.Body, this.partSize);\n    for (let index = 0; index < this.queueSize; index++) {\n      const currentUpload = this.__doConcurrentUpload(dataFeeder);\n      this.concurrentUploaders.push(currentUpload);\n    }\n    await Promise.all(this.concurrentUploaders);\n    if (this.abortController.signal.aborted) {\n      throw Object.assign(new Error(\"Upload aborted.\"), {\n        name: \"AbortError\"\n      });\n    }\n    let result;\n    if (this.isMultiPart) {\n      this.uploadedParts.sort((a, b) => a.PartNumber - b.PartNumber);\n      const uploadCompleteParams = {\n        ...this.params,\n        Body: undefined,\n        UploadId: this.uploadId,\n        MultipartUpload: {\n          Parts: this.uploadedParts\n        }\n      };\n      result = await this.client.send(new CompleteMultipartUploadCommand(uploadCompleteParams));\n    } else {\n      result = this.singleUploadResult;\n    }\n    if (this.tags.length) {\n      await this.client.send(new PutObjectTaggingCommand({\n        ...this.params,\n        Tagging: {\n          TagSet: this.tags\n        }\n      }));\n    }\n    return result;\n  }\n  __notifyProgress(progress) {\n    if (this.uploadEvent) {\n      this.emit(this.uploadEvent, progress);\n    }\n  }\n  async __abortTimeout(abortSignal) {\n    return new Promise((resolve, reject) => {\n      abortSignal.onabort = () => {\n        const abortError = new Error(\"Upload aborted.\");\n        abortError.name = \"AbortError\";\n        reject(abortError);\n      };\n    });\n  }\n  __validateInput() {\n    if (!this.params) {\n      throw new Error(`InputError: Upload requires params to be passed to upload.`);\n    }\n    if (!this.client) {\n      throw new Error(`InputError: Upload requires a AWS client to do uploads with.`);\n    }\n    if (this.partSize < MIN_PART_SIZE) {\n      throw new Error(`EntityTooSmall: Your proposed upload partsize [${this.partSize}] is smaller than the minimum allowed size [${MIN_PART_SIZE}] (5MB)`);\n    }\n    if (this.queueSize < 1) {\n      throw new Error(`Queue size: Must have at least one uploading queue.`);\n    }\n  }\n}","map":{"version":3,"names":["CompleteMultipartUploadCommand","CreateMultipartUploadCommand","PutObjectCommand","PutObjectTaggingCommand","UploadPartCommand","AbortController","getEndpointFromInstructions","toEndpointV1","extendedEncodeURIComponent","EventEmitter","byteLength","getChunk","MIN_PART_SIZE","Upload","constructor","options","MAX_PARTS","queueSize","partSize","leavePartsOnError","tags","concurrentUploaders","uploadedParts","isMultiPart","client","params","__validateInput","totalBytes","Body","bytesUploadedSoFar","abortController","abort","done","Promise","race","__doMultipartUpload","__abortTimeout","signal","on","event","listener","uploadEvent","__uploadUsingPut","dataPart","data","clientConfig","config","requestHandler","eventEmitter","uploadEventListener","loaded","total","__notifyProgress","part","partNumber","Key","Bucket","resolved","all","send","endpoint","putResult","Error","off","locationKey","split","map","segment","join","locationBucket","Location","endpointHostnameIncludesBucket","hostname","startsWith","forcePathStyle","protocol","singleUploadResult","totalSize","__createMultipartUpload","createMultiPartPromise","createCommandParams","undefined","__doConcurrentUpload","dataFeeder","length","aborted","lastPart","uploadId","UploadId","lastSeenBytes","request","requestPartSize","Number","query","partResult","PartNumber","ETag","push","ChecksumCRC32","ChecksumCRC32C","ChecksumSHA1","ChecksumSHA256","e","index","currentUpload","Object","assign","name","result","sort","a","b","uploadCompleteParams","MultipartUpload","Parts","Tagging","TagSet","progress","emit","abortSignal","resolve","reject","onabort","abortError"],"sources":["D:/Work/00-Mogul/konva v2/node_modules/@aws-sdk/lib-storage/dist-es/Upload.js"],"sourcesContent":["import { CompleteMultipartUploadCommand, CreateMultipartUploadCommand, PutObjectCommand, PutObjectTaggingCommand, UploadPartCommand, } from \"@aws-sdk/client-s3\";\nimport { AbortController } from \"@smithy/abort-controller\";\nimport { getEndpointFromInstructions, toEndpointV1, } from \"@smithy/middleware-endpoint\";\nimport { extendedEncodeURIComponent } from \"@smithy/smithy-client\";\nimport { EventEmitter } from \"events\";\nimport { byteLength } from \"./bytelength\";\nimport { getChunk } from \"./chunker\";\nconst MIN_PART_SIZE = 1024 * 1024 * 5;\nexport class Upload extends EventEmitter {\n    constructor(options) {\n        super();\n        this.MAX_PARTS = 10000;\n        this.queueSize = 4;\n        this.partSize = MIN_PART_SIZE;\n        this.leavePartsOnError = false;\n        this.tags = [];\n        this.concurrentUploaders = [];\n        this.uploadedParts = [];\n        this.isMultiPart = true;\n        this.queueSize = options.queueSize || this.queueSize;\n        this.partSize = options.partSize || this.partSize;\n        this.leavePartsOnError = options.leavePartsOnError || this.leavePartsOnError;\n        this.tags = options.tags || this.tags;\n        this.client = options.client;\n        this.params = options.params;\n        this.__validateInput();\n        this.totalBytes = byteLength(this.params.Body);\n        this.bytesUploadedSoFar = 0;\n        this.abortController = options.abortController ?? new AbortController();\n    }\n    async abort() {\n        this.abortController.abort();\n    }\n    async done() {\n        return await Promise.race([this.__doMultipartUpload(), this.__abortTimeout(this.abortController.signal)]);\n    }\n    on(event, listener) {\n        this.uploadEvent = event;\n        return super.on(event, listener);\n    }\n    async __uploadUsingPut(dataPart) {\n        this.isMultiPart = false;\n        const params = { ...this.params, Body: dataPart.data };\n        const clientConfig = this.client.config;\n        const requestHandler = clientConfig.requestHandler;\n        const eventEmitter = requestHandler instanceof EventEmitter ? requestHandler : null;\n        const uploadEventListener = (event) => {\n            this.bytesUploadedSoFar = event.loaded;\n            this.totalBytes = event.total;\n            this.__notifyProgress({\n                loaded: this.bytesUploadedSoFar,\n                total: this.totalBytes,\n                part: dataPart.partNumber,\n                Key: this.params.Key,\n                Bucket: this.params.Bucket,\n            });\n        };\n        if (eventEmitter !== null) {\n            eventEmitter.on(\"xhr.upload.progress\", uploadEventListener);\n        }\n        const resolved = await Promise.all([this.client.send(new PutObjectCommand(params)), clientConfig?.endpoint?.()]);\n        const putResult = resolved[0];\n        let endpoint = resolved[1];\n        if (!endpoint) {\n            endpoint = toEndpointV1(await getEndpointFromInstructions(params, PutObjectCommand, {\n                ...clientConfig,\n            }));\n        }\n        if (!endpoint) {\n            throw new Error('Could not resolve endpoint from S3 \"client.config.endpoint()\" nor EndpointsV2.');\n        }\n        if (eventEmitter !== null) {\n            eventEmitter.off(\"xhr.upload.progress\", uploadEventListener);\n        }\n        const locationKey = this.params\n            .Key.split(\"/\")\n            .map((segment) => extendedEncodeURIComponent(segment))\n            .join(\"/\");\n        const locationBucket = extendedEncodeURIComponent(this.params.Bucket);\n        const Location = (() => {\n            const endpointHostnameIncludesBucket = endpoint.hostname.startsWith(`${locationBucket}.`);\n            const forcePathStyle = this.client.config.forcePathStyle;\n            if (forcePathStyle) {\n                return `${endpoint.protocol}//${endpoint.hostname}/${locationBucket}/${locationKey}`;\n            }\n            if (endpointHostnameIncludesBucket) {\n                return `${endpoint.protocol}//${endpoint.hostname}/${locationKey}`;\n            }\n            return `${endpoint.protocol}//${locationBucket}.${endpoint.hostname}/${locationKey}`;\n        })();\n        this.singleUploadResult = {\n            ...putResult,\n            Bucket: this.params.Bucket,\n            Key: this.params.Key,\n            Location,\n        };\n        const totalSize = byteLength(dataPart.data);\n        this.__notifyProgress({\n            loaded: totalSize,\n            total: totalSize,\n            part: 1,\n            Key: this.params.Key,\n            Bucket: this.params.Bucket,\n        });\n    }\n    async __createMultipartUpload() {\n        if (!this.createMultiPartPromise) {\n            const createCommandParams = { ...this.params, Body: undefined };\n            this.createMultiPartPromise = this.client.send(new CreateMultipartUploadCommand(createCommandParams));\n        }\n        return this.createMultiPartPromise;\n    }\n    async __doConcurrentUpload(dataFeeder) {\n        for await (const dataPart of dataFeeder) {\n            if (this.uploadedParts.length > this.MAX_PARTS) {\n                throw new Error(`Exceeded ${this.MAX_PARTS} as part of the upload to ${this.params.Key} and ${this.params.Bucket}.`);\n            }\n            try {\n                if (this.abortController.signal.aborted) {\n                    return;\n                }\n                if (dataPart.partNumber === 1 && dataPart.lastPart) {\n                    return await this.__uploadUsingPut(dataPart);\n                }\n                if (!this.uploadId) {\n                    const { UploadId } = await this.__createMultipartUpload();\n                    this.uploadId = UploadId;\n                    if (this.abortController.signal.aborted) {\n                        return;\n                    }\n                }\n                const partSize = byteLength(dataPart.data) || 0;\n                const requestHandler = this.client.config.requestHandler;\n                const eventEmitter = requestHandler instanceof EventEmitter ? requestHandler : null;\n                let lastSeenBytes = 0;\n                const uploadEventListener = (event, request) => {\n                    const requestPartSize = Number(request.query[\"partNumber\"]) || -1;\n                    if (requestPartSize !== dataPart.partNumber) {\n                        return;\n                    }\n                    if (event.total && partSize) {\n                        this.bytesUploadedSoFar += event.loaded - lastSeenBytes;\n                        lastSeenBytes = event.loaded;\n                    }\n                    this.__notifyProgress({\n                        loaded: this.bytesUploadedSoFar,\n                        total: this.totalBytes,\n                        part: dataPart.partNumber,\n                        Key: this.params.Key,\n                        Bucket: this.params.Bucket,\n                    });\n                };\n                if (eventEmitter !== null) {\n                    eventEmitter.on(\"xhr.upload.progress\", uploadEventListener);\n                }\n                const partResult = await this.client.send(new UploadPartCommand({\n                    ...this.params,\n                    UploadId: this.uploadId,\n                    Body: dataPart.data,\n                    PartNumber: dataPart.partNumber,\n                }));\n                if (eventEmitter !== null) {\n                    eventEmitter.off(\"xhr.upload.progress\", uploadEventListener);\n                }\n                if (this.abortController.signal.aborted) {\n                    return;\n                }\n                if (!partResult.ETag) {\n                    throw new Error(`Part ${dataPart.partNumber} is missing ETag in UploadPart response. Missing Bucket CORS configuration for ETag header?`);\n                }\n                this.uploadedParts.push({\n                    PartNumber: dataPart.partNumber,\n                    ETag: partResult.ETag,\n                    ...(partResult.ChecksumCRC32 && { ChecksumCRC32: partResult.ChecksumCRC32 }),\n                    ...(partResult.ChecksumCRC32C && { ChecksumCRC32C: partResult.ChecksumCRC32C }),\n                    ...(partResult.ChecksumSHA1 && { ChecksumSHA1: partResult.ChecksumSHA1 }),\n                    ...(partResult.ChecksumSHA256 && { ChecksumSHA256: partResult.ChecksumSHA256 }),\n                });\n                if (eventEmitter === null) {\n                    this.bytesUploadedSoFar += partSize;\n                }\n                this.__notifyProgress({\n                    loaded: this.bytesUploadedSoFar,\n                    total: this.totalBytes,\n                    part: dataPart.partNumber,\n                    Key: this.params.Key,\n                    Bucket: this.params.Bucket,\n                });\n            }\n            catch (e) {\n                if (!this.uploadId) {\n                    throw e;\n                }\n                if (this.leavePartsOnError) {\n                    throw e;\n                }\n            }\n        }\n    }\n    async __doMultipartUpload() {\n        const dataFeeder = getChunk(this.params.Body, this.partSize);\n        for (let index = 0; index < this.queueSize; index++) {\n            const currentUpload = this.__doConcurrentUpload(dataFeeder);\n            this.concurrentUploaders.push(currentUpload);\n        }\n        await Promise.all(this.concurrentUploaders);\n        if (this.abortController.signal.aborted) {\n            throw Object.assign(new Error(\"Upload aborted.\"), { name: \"AbortError\" });\n        }\n        let result;\n        if (this.isMultiPart) {\n            this.uploadedParts.sort((a, b) => a.PartNumber - b.PartNumber);\n            const uploadCompleteParams = {\n                ...this.params,\n                Body: undefined,\n                UploadId: this.uploadId,\n                MultipartUpload: {\n                    Parts: this.uploadedParts,\n                },\n            };\n            result = await this.client.send(new CompleteMultipartUploadCommand(uploadCompleteParams));\n        }\n        else {\n            result = this.singleUploadResult;\n        }\n        if (this.tags.length) {\n            await this.client.send(new PutObjectTaggingCommand({\n                ...this.params,\n                Tagging: {\n                    TagSet: this.tags,\n                },\n            }));\n        }\n        return result;\n    }\n    __notifyProgress(progress) {\n        if (this.uploadEvent) {\n            this.emit(this.uploadEvent, progress);\n        }\n    }\n    async __abortTimeout(abortSignal) {\n        return new Promise((resolve, reject) => {\n            abortSignal.onabort = () => {\n                const abortError = new Error(\"Upload aborted.\");\n                abortError.name = \"AbortError\";\n                reject(abortError);\n            };\n        });\n    }\n    __validateInput() {\n        if (!this.params) {\n            throw new Error(`InputError: Upload requires params to be passed to upload.`);\n        }\n        if (!this.client) {\n            throw new Error(`InputError: Upload requires a AWS client to do uploads with.`);\n        }\n        if (this.partSize < MIN_PART_SIZE) {\n            throw new Error(`EntityTooSmall: Your proposed upload partsize [${this.partSize}] is smaller than the minimum allowed size [${MIN_PART_SIZE}] (5MB)`);\n        }\n        if (this.queueSize < 1) {\n            throw new Error(`Queue size: Must have at least one uploading queue.`);\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}